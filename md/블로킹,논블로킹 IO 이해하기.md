# 블로킹(Blocking) vs 논블로킹(Non-Blocking) IO 🔄

IO(Input/Output)는 시스템의 데이터를 입력받거나 출력하는 모든 작업을 뜻합니다. 블로킹과 논블로킹은 이러한 IO 작업이 처리되는 방식에 따라 나뉩니다.

---

## 1. 블로킹 IO란? 🛑
블로킹 IO는 **요청한 작업이 완료될 때까지 대기**하는 방식입니다.  
이 동안 다른 작업은 진행되지 않으며, 해당 스레드(Thread)는 요청된 작업이 끝날 때까지 **블록(Block)** 상태에 머무릅니다.

### 🔍 특징
- **직관적 설계**: 이해하기 쉽고 구현이 간단.
- **리소스 비효율성**: 대기 시간이 길어질 경우 비효율적.
- 한 스레드가 IO 작업에 묶이면 다른 작업을 수행할 수 없음.

---

## 2. 논블로킹 IO란? 🚀
논블로킹 IO는 **작업이 즉시 실행되지 않더라도 다른 작업을 계속 진행**할 수 있는 방식입니다.  
스레드는 IO 요청을 보내고, 데이터가 준비될 때까지 기다리지 않고 다른 작업을 수행합니다.

### 🔍 특징
- **효율적 리소스 사용**: 스레드가 작업을 차단하지 않음.
- **복잡한 설계**: 상태 관리와 콜백 처리 등으로 구현이 복잡할 수 있음.
- 이벤트 기반으로 동작하며, 결과를 받을 때까지 상태를 추적.

---

## 3. 주요 차이점 비교 🔄

| 특성             | 블로킹 IO 🛑                     | 논블로킹 IO 🚀                  |
|------------------|----------------------------------|---------------------------------|
| **작업 방식**     | 요청 완료 시까지 대기            | 요청 즉시 반환, 대기 없음        |
| **스레드 상태**   | 블록(대기) 상태                 | 자유롭게 다른 작업 가능          |
| **구현 난이도**   | 간단                            | 복잡 (상태 관리, 콜백 필요)     |
| **효율성**        | 리소스 비효율적                 | 리소스 효율적                   |
| **적용 사례**     | 단순한 소규모 애플리케이션       | 대규모 동시성 처리 애플리케이션  |

---

## 4. 블로킹/논블로킹 IO의 선택 기준 🤔
- **블로킹 IO**: 간단하고 직관적인 설계를 원하는 소규모 프로젝트.
- **논블로킹 IO**: 높은 동시성과 성능을 요구하는 대규모 애플리케이션.  

> 예를 들어, Spring WebFlux는 논블로킹 IO 기반으로 작동하여 높은 효율성과 동시성 처리를 지원합니다.

---

> **📚 참고 자료**  
> - [Blocking vs Non-Blocking IO Explained](https://example.com)  
> - [Java NIO 공식 문서](https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html)
